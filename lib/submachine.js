// Generated by CoffeeScript 1.4.0
(function() {
  var Submachine, exports,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Submachine = (function() {
    var clone, isArray;

    isArray = Array.isArray || function(maybe_array) {
      return {}.toString.apply(maybe_array) === "[object Array]";
    };

    clone = function(obj) {
      var c, key;
      if (!((obj != null) && typeof obj === "object")) {
        return obj;
      }
      c = new obj.constructor();
      for (key in obj) {
        c[key] = clone(obj[key]);
      }
      return c;
    };

    Submachine.hasStates = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (isArray(args[0])) {
        return this.prototype._states = args[0];
      } else {
        return this.prototype._states = args;
      }
    };

    Submachine.transition = function(obj) {
      var _base, _base1, _base2, _name, _name1, _ref, _ref1, _ref2;
      if (!((obj != null) && (obj.from != null) && (obj.to != null) && (obj.on != null))) {
        throw new Error("transition must define 'from', 'to' and 'on'");
      }
      if ((_ref = (_base = this.prototype)._events) == null) {
        _base._events = {};
      }
      if (!this.prototype.hasOwnProperty("_events")) {
        this.prototype._events = clone(this.prototype._events);
      }
      if ((_ref1 = (_base1 = this.prototype._events)[_name = obj.on]) == null) {
        _base1[_name] = [];
      }
      this.prototype._events[obj.on].push({
        from: obj.from,
        to: obj.to
      });
      return (_ref2 = (_base2 = this.prototype)[_name1 = obj.on]) != null ? _ref2 : _base2[_name1] = function() {
        var args, tr, _i, _len, _ref3, _results;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        _ref3 = this._events[obj.on];
        _results = [];
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          tr = _ref3[_i];
          if (this.state === tr.from || tr.from === "*") {
            this.switchTo.apply(this, [tr.to].concat(__slice.call(args)));
            break;
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };
    };

    Submachine._addStateCallback = function(state, type, cbk) {
      var _base, _base1, _base2, _ref, _ref1, _ref2;
      if ((_ref = (_base = this.prototype)._callbacks) == null) {
        _base._callbacks = {};
      }
      if (!this.prototype.hasOwnProperty("_callbacks")) {
        this.prototype._callbacks = clone(this.prototype._callbacks);
      }
      if ((_ref1 = (_base1 = this.prototype._callbacks)[state]) == null) {
        _base1[state] = {};
      }
      if ((_ref2 = (_base2 = this.prototype._callbacks[state])[type]) == null) {
        _base2[type] = [];
      }
      return this.prototype._callbacks[state][type].push(cbk);
    };

    Submachine.onEnter = function(state, cbk) {
      return this._addStateCallback(state, "onEnter", cbk);
    };

    Submachine.onLeave = function(state, cbk) {
      return this._addStateCallback(state, "onLeave", cbk);
    };

    Submachine.setupState = function(state, cbks) {
      if (cbks == null) {
        cbks = {};
      }
      if (cbks.onEnter != null) {
        this.onEnter(state, cbks.onEnter);
      }
      if (cbks.onLeave != null) {
        return this.onLeave(state, cbks.onLeave);
      }
    };

    Submachine.subclass = function(fn) {
      var Subclass;
      Subclass = (function(_super) {

        __extends(Subclass, _super);

        function Subclass() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          if (this.initialize != null) {
            this.initialize.apply(this, args);
          } else {
            Subclass.__super__.constructor.apply(this, args);
          }
        }

        return Subclass;

      })(this);
      if (fn != null) {
        fn.call(Subclass, Subclass.prototype);
      }
      return Subclass;
    };

    function Submachine(state) {
      if (state != null) {
        this.initState(state);
      }
    }

    Submachine.prototype.initState = function(state) {
      if (this.state != null) {
        throw new Error("state was already initialized");
      }
      return this.switchTo(state);
    };

    Submachine.prototype.switchTo = function() {
      var args, state;
      state = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (__indexOf.call(this._states, state) < 0) {
        throw new Error("invalid state " + state);
      }
      if (this.state != null) {
        this._invokeStateCallbacks(this.state, "onLeave", args);
      }
      this.state = state;
      return this._invokeStateCallbacks(this.state, "onEnter", args);
    };

    Submachine.prototype._invokeStateCallbacks = function(state, type, args) {
      var cbk, _i, _len, _ref, _ref1, _ref2, _results;
      if (state !== "*") {
        this._invokeStateCallbacks("*", type, args);
      }
      _ref2 = ((_ref = this._callbacks) != null ? (_ref1 = _ref[state]) != null ? _ref1[type] : void 0 : void 0) || [];
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        cbk = _ref2[_i];
        _results.push(cbk.apply(this, args));
      }
      return _results;
    };

    return Submachine;

  })();

  if (typeof exports !== "undefined" && exports !== null) {
    if ((typeof module !== "undefined" && module !== null) && (module.exports != null)) {
      exports = module.exports = Submachine;
    }
    exports.Submachine = Submachine;
  } else if (typeof define === "function" && define.amd) {
    define(function() {
      return Submachine;
    });
  } else {
    this.Submachine = Submachine;
  }

}).call(this);
